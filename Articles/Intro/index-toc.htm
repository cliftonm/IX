<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>TypeScript</title>
</head>

<body>

<p>Exploring Proxy to Achieve TypeScript Type Safety with Element Binding, two way 
Data Binding, Events, and More</p>
<p>An Alice in Wonderland journey into the nuances of using Proxy with HTML and 
TypeScript classes.</p>
<p><img border="0" src="titlescreen.png" width="504" height="478"></p>

<h2>Contents</h2><ul>
<li><a href="#Introduction0">Introduction</a></li>
<ul>
<li><a href="#Pros1">Pros</a></li>
<li><a href="#Cons2">Cons</a></li>
<li><a href="#SoWhyBother3">So Why Bother?</a></li>
</ul>
<li><a href="#WhatisaProxy4">What is a Proxy?</a></li>
<ul>
<li><a href="#ASimpleExample5">A Simple Example</a></li>
<li><a href="#ADOMExample6">A DOM Example</a></li>
<li><a href="#ThePointBeing...7">The Point Being...</a></li>
</ul>
<li><a href="#AboutTheCode8">About The Code</a></li>
<li><a href="#SimpleDataBindingofInnerHTML9">Simple Data Binding of Inner HTML</a></li>
<ul>
<li><a href="#TheVueWay10">The Vue Way</a></li>
<li><a href="#TheIXWay11">The IX Way</a></li>
</ul>
<li><a href="#ReactiveBehavior12">Reactive Behavior</a></li>
<ul>
<li><a href="#TheVueWay13">The Vue Way</a></li>
<li><a href="#TheIXWay14">The IX Way</a></li>
</ul>
<li><a href="#Conditionals15">Conditionals</a></li>
<ul>
<li><a href="#TheVueWay16">The Vue Way</a></li>
<li><a href="#TheIXWay17">The IX Way</a></li>
</ul>
<li><a href="#Loops18">Loops</a></li>
<ul>
<li><a href="#TheVueWay19">The Vue Way</a></li>
<li><a href="#TheIXWay20">The IX Way</a></li>
</ul>
<li><a href="#ButtonClicks21">Button Clicks</a></li>
<ul>
<li><a href="#TheVueWay22">The Vue Way</a></li>
<li><a href="#TheIXWay23">The IX Way</a></li>
</ul>
<li><a href="#DataConversion24">Data Conversion</a></li>
<li><a href="#TwoWayBinding25">Two Way Binding</a></li>
<ul>
<li><a href="#TheVueWay26">The Vue Way</a></li>
<li><a href="#TheIXWay27">The IX Way</a></li>
</ul>
<li><a href="#Checkboxes28">Checkboxes</a></li>
<ul>
<li><a href="#BindingCheckboxState29">Binding Checkbox State</a></li>
<ul>
<li><a href="#TheVueWay30">The Vue Way</a></li>
<li><a href="#TheIXWay31">The IX Way</a></li>
</ul>
<li><a href="#BindingCheckboxValues32">Binding Checkbox Values</a></li>
<ul>
<li><a href="#TheViewWay33">The View Way</a></li>
<li><a href="#TheIXWay34">The IX Way</a></li>
</ul>
</ul>
<li><a href="#RadioButtons35">Radio Buttons</a></li>
<ul>
<li><a href="#TheViewWay36">The View Way</a></li>
<li><a href="#TheIXWay37">The IX Way</a></li>
</ul>
<li><a href="#ComboBoxes38">ComboBoxes</a></li>
<ul>
<li><a href="#TheVueWay39">The Vue Way</a></li>
<li><a href="#TheIXWay40">The IX Way</a></li>
</ul>
<li><a href="#ImplementationPatterns41">Implementation Patterns</a></li>
<ul>
<li><a href="#IDandClassPropertyName42">ID and Class Property Name</a></li>
<li><a href="#KeyUp,Changed,andConvertEvents43">KeyUp, Changed, and Convert Events</a></li>
<li><a href="#SupportedEvents44">Supported Events</a></li>
<ul>
<li><a href="#KeyUp45">KeyUp</a></li>
<li><a href="#Changed46">Changed</a></li>
<li><a href="#Convert47">Convert</a></li>
<li><a href="#Hover48">Hover</a></li>
</ul>
</ul>
<li><a href="#IntegrationTests49">Integration Tests</a></li>
<ul>
<li><a href="#TheTestRunner50">The Test Runner</a></li>
<li><a href="#DefiningtheTests51">Defining the Tests</a></li>
<li><a href="#TheIXAssertHelper52">The IXAssert Helper</a></li>
<li><a href="#YouDon'tNeedTypeScriptClasses53">You Don't Need TypeScript Classes</a></li>
</ul>
<li><a href="#BehindtheScenes54">Behind the Scenes</a></li>
<ul>
<li><a href="#TypeScriptDoesNotMeanRuntimeTypeReflection55">TypeScript Does Not Mean Runtime Type Reflection</a></li>
<li><a href="#ProxyInitialization56">Proxy Initialization</a></li>
<ul>
<li><a href="#CreatePropertyHandlers57">CreatePropertyHandlers</a></li>
<li><a href="#WireUpEventHandler58">WireUpEventHandler</a></li>
<li><a href="#CustomConverter59">CustomConverter</a></li>
</ul>
<li><a href="#CreateButtonHandlers60">CreateButtonHandlers</a></li>
<li><a href="#CreateBinders61">CreateBinders</a></li>
<li><a href="#Initialize62">Initialize</a></li>
<li><a href="#Arrays63">Arrays</a></li>
<li><a href="#IXEvent64">IXEvent</a></li>
<li><a href="#IXTemplate65">IXTemplate</a></li>
</ul>
<li><a href="#Conclusion66">Conclusion</a></li>
<ul>
<li><a href="#DoIneedaProxy67">Do I need a Proxy?</a></li>
<li><a href="#BothProxyandDOMWrapper68">Both Proxy and DOM Wrapper</a></li>
<li><a href="#TheFutureIsEmerging69">The Future Is Emerging</a></li>
</ul>
</ul>


<h2><a name="Introduction0">Introduction</a></h2>
<p>I despise two things about front-end development:</p>
<ol>
	<li>Element ID's are string literals.</li>
	<li>Javascript code in my HTML.</li>
	<li>Javascript.</li>
	<li>Actually anything having to do with front-end development, but that's 
	life.</li>
</ol>
<p>Oh wait.&nbsp; That's four things.</p>
<p>When I started writing the code for this article, I ended up experience what 
something that <a href="https://www.presencing.org/aboutus/theory-u">Theory U</a> 
describes as &quot;Leading From the Future As It Emerges.&quot;&nbsp; Riiiight.&nbsp; 
Sounds like BS, doesn't it?&nbsp; None-the-less, this was my experience:</p>
<p><img border="0" src="theu.png" width="533" height="299"></p>
<p>So my &quot;future&quot; was discovering that the code I'm about to present here is, 
well, not what I would actually want to use, now that the future as arrived in 
the present and by the time I finished writing this article, I realized there's 
a lot of things I would do differently!&nbsp; Regardless, I have found it a useful 
exploration of how to leverage the Proxy type to bind class properties to 
models, achieve two way binding, subscribe to UI events, and so forth, all using 
actual &quot;edit-time&quot; types for type safety and Intellisense support - as in, no 
strings referencing DOM elements by their ID's.&nbsp; Thus &quot;IX&quot; is born, which 
is short for &quot;Interacx&quot;, which was a WinForm suite of tools that I created a 
long time ago to automate data manipulation without using an ORM.&nbsp; I 
decided to repurpose the name since WinForm applications are, well, passï¿½, and 
the reality is that the thing I despise, writing web apps, it where it's app, I 
mean, at.&nbsp; And for your endless amusement, I decided to use some Vue examples as 
comparison to the implementation I've developed here using proxies.</p>
<h3><a name="Pros1">Pros</a></h3>
<p>Working with the code I've developed here, I find several advantages:</p>
<ol>
	<li>I'm not hardcoding DOM ID string literals.</li>
	<li>I'm able to leverage the type safety of TypeScript.</li>
<li>Being able to refer to DOM elements as object properties leverages Visual 
Studio's Intellisense.</li>
	<li>It's really easy to wire up events and bindings.</li>
<li>It was quite easy to write unit tests - in fact, the unit tests are one of 
the more interesting aspects of this code, in my opinion.</li>
	<li>I'm not putting &quot;declarative code&quot; in the HTML<ol>
	<li>The HTML remains completely clean.</li>
	<li>The business logic is implemented in code. </li>
	<li>You don't have to inspect both code and HTML to figure out what in the 
	world is actually going on.</li>
</ol></li>
	<li>Point #6</li>
	<li>Point #6</li>
	<li>Point #6</li>
</ol>
<p>I cannot reiterate enough how important, at least to me, point #6 is.&nbsp; 
With a large web application, I have pulled my hair out bouncing between code 
and markup to figure out what the conditions, loops, and rendering is, and it is 
a frustrating experience.&nbsp; To me, the idea of including declarative syntax 
at the UI level that is driven by effectively business data/rules is bad, no 
horrible, design.&nbsp; It's why I don't use Razor or similar rendering engines.&nbsp; 
I personally think that arcane custom tags in the HTML, &quot;if&quot; and &quot;loop&quot; 
tags, etc., to control UI rendering is one of the worst ideas to come out of so-called 
modern web development.</p>
<h3><a name="Cons2">Cons</a></h3>
<p>So let's be realistic:</p>
<ol>
	<li>The syntax requires a specific mapping between the DOM element ID and 
	the object's property name.</li>
<li>Proxies are slower.</li>
	<li>The code to work with proxies is highly specialized.</li>
	<li>The code to work with arrays is bizarre.</li>
	<li>The code here is really incomplete with regards to all the DOM 
	attributes, properties, and events that could be handled.</li>
	<li>I have no idea whether the code here is actually robust enough to handle 
	#4.</li>
	<li>I have yet to explore whether this concept works well with third party 
	widget libraries, my favorite being jqWidgets.</li>
	<li>The &quot;future&quot; arrived rather late, basically by the time I was done 
	writing this article.</li>
</ol>
<p>And I really doubt anyone is going to say, &quot;ooh, let's use IX to build a 
major website&quot;, except perhaps for me!</p>
<h3><a name="SoWhyBother3">So Why Bother?</a></h3>
<ol>
	<li>I like to explore different ways to solve the warts of web development.</li>
<li>I haven't come across anyone else attempting this.</li>
	<li>It's quite interesting to learn about proxies.</li>
<li>This was fun!</li>
</ol>
	<h2><a name="WhatisaProxy4">What is a Proxy?</a></h2>
<p>A <code>Proxy</code>, at least in Javascript, is an object that replaces your object and 
lets you intercept the &quot;get&quot; and &quot;set&quot; methods.&nbsp; Read 
more about the <code>Proxy</code> object
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">
here</a>.&nbsp; </p>
<h3><a name="ASimpleExample5">A Simple Example</a></h3>
<p>I simple demonstration will suffice.&nbsp; First, a simple proxy 
stub that just does the get/set operations with console logging:</p>
<pre>private myProxyHandler = {
  get: (obj, prop) =&gt; {
    console.log(`get ${prop}`);

    return obj[prop];
  },

  set: (obj, prop, val) =&gt; {
    console.log(`set ${prop} to ${val}`);
    obj[prop] = val;

    // Return true to accept change.
    return true;
  }
}</pre>
<p>And a simple test case:</p>
<pre>let proxy = new Proxy({}, this.myProxyHandler);
proxy.foo = 1;
let foo = proxy.foo;
console.log(`foo = ${foo}`);</pre>
<p>and the output:</p>
<pre>set foo to 1
get foo
foo = 1</pre>
<p>Ahh, feel the power!&nbsp; The world is now mine!</p>
<h3><a name="ADOMExample6">A DOM Example</a></h3>
<p>Now let's do something a little more interesting.&nbsp; We'll create a class 
with a property whose name matches a DOM element.&nbsp; The DOM element, with a 
label because input elements should have labels:</p>
<pre>&lt;div class=&quot;inline marginTop5&quot;&gt;
  &lt;div class=&quot;inline label&quot;&gt;Name:&lt;/div&gt;
  &lt;div class=&quot;inline&quot;&gt;&lt;input id=&quot;name&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;</pre>
<p><img border="0" src="ex1.png" width="210" height="28"></p>
<p>Exciting!</p>
<p>Now the class:</p>
<pre>class NameContainer {
  name: string;
}</pre>
<p>And the new proxy:</p>
<pre>private valueProxy = {
  get: (obj, prop) =&gt; {
    console.log(`get ${prop}`);

    return obj[prop];
  },

  set: (obj, prop, val) =&gt; {
    console.log(`set ${prop} to ${val}`);

    let el = document.getElementById(prop) as HTMLInputElement;
    el.value = val;
    obj[prop] = val;

    // Return true to accept change.
    return true;
  }
}</pre>
<p>Notice the only thing I've added is this:</p>
<pre>let el = document.getElementById(prop) as HTMLInputElement;
el.value = val;</pre>
<p>Here the assumption is that the property name is the element ID!</p>
<p>Now we can set the value and it proxies to setting both the object's <code>name</code> property 
and the DOM <code>value</code> property:</p>
<pre>let nc = new Proxy(new NameContainer(), this.valueProxy);
nc.name = &quot;Hello World!&quot;;
</pre>
<p>The result is:</p>
<p><img border="0" src="ex2.png" width="208" height="30"></p>
<p>What if I type something in and I want to see that value when I &quot;get&quot; the 
<code>name</code> property?&nbsp; Easy enough, the getter changes to this:</p>
<pre>get: (obj, prop) =&gt; {
  console.log(`get ${prop}`);

  let el = document.getElementById(prop) as HTMLInputElement;
  let val = el.value;
  obj[prop] = val;

  return obj[prop];
},</pre>
<p>We can test the code by simulating a change the user made:</p>
<pre>let nc = new Proxy(new NameContainer(), this.valueProxy);
nc.name = &quot;Hello World!&quot;;

// Simulate the user having changed the input box:
let el = document.getElementById(&quot;name&quot;) as HTMLInputElement;
el.value = &quot;fizbin&quot;;

let newName = nc.name;
console.log(`The new name is: ${newName}`);</pre>
<p>and in the console log, we see:</p>
<pre>set name to Hello World!
get name
The new name is: fizbin</pre>
<p>It's important to note that <code>obj[prop] = val</code> makes the assignment on the non-proxy'd 
object, therefore the proxy <i>setter</i> does not get called.</p>
<h3><a name="ThePointBeing...7">The Point Being...</a></h3>
<ol>
	<li>I'm using types (and therefore Intellisense) to get/set the DOM element 
	value.</li>
<li>I've eliminated the string literal for the name by assuming that the name of 
the class property is the same as the element ID.</li>
</ol>
<p>Snazzy!&nbsp; One small step for Marc, one giant leap for better front-end 
development!&nbsp; Unfortunately, getting to the moon requires a whole lot more 
effort, infrastructure, time, and a lot of disasters along the way (a pause here 
to recognize the lives that have been lost in space exploration, as I don't want 
to appear&nbsp; flippant about &quot;disasters.&quot;)</p>
<p>So, let's start the journey down the slope of the U!</p>
<h2><a name="AboutTheCode8">About The Code</a></h2>
<p>The code is TypeScript with simple HTML and CSS, implemented in VS2017 
solution.</p>
<p>The source code can also be found at:
<a href="https://github.com/cliftonm/IX">https://github.com/cliftonm/IX</a></p>
<p>There are two HTML pages to play with:</p>
<ol>
	<li>index.html is the demo page</li>
	<li>Tests/IntegrationTests.html runs the integration tests.</li>
</ol>
<h2><a name="SimpleDataBindingofInnerHTML9">Simple Data Binding of Inner HTML</a></h2>
<p>Let's start with simple data binding of the inner HTML associated with a <code>DIV</code>.</p>
<h3><a name="TheVueWay10">The Vue Way</a></h3>
<pre>&lt;div id=&quot;app&quot;&gt;
  {{ message }}
&lt;/div&gt;

var app = new Vue({
  el: '#app',
  data: {
   message: 'Hello Vue!'
  }
})</pre>
<p>What I don't like:</p>
<ol>
	<li>The &quot;Mustache&quot; <code>{{ }}</code> usage.</li>
	<li>The <code>#app</code>.</li>
	<li>The whole <code>data</code> object thing.</li>
</ol>
<h3><a name="TheIXWay11">The IX Way</a></h3>
<pre>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

let form = IX.CreateNullProxy(); // No associated view model.
form.app = &quot;Hello Interacx!&quot;;</pre>
<p><img border="0" src="helloIX.png" width="114" height="26"></p>
<p>That's it.</p>
<h2><a name="ReactiveBehavior12">Reactive Behavior</a></h2>
<p>The next example is displaying some realtime computed value as part of a SPAN 
title.</p>
<h3><a name="TheVueWay13">The Vue Way</a></h3>
<pre>&lt;div id=&quot;app-2&quot;&gt;
  &lt;span v-bind:title=&quot;message&quot;&gt;
    Hover your mouse over me for a few seconds
    to see my dynamically bound title!
  &lt;/span&gt;
&lt;/div&gt;

var app2 = new Vue({
  el: '#app-2',
  data: {
    message: 'You loaded this page on ' + new Date().toLocaleString()
  }
})</pre>
<h3><a name="TheIXWay14">The IX Way</a></h3>
<pre>&lt;span id=&quot;mySpan&quot;&gt;However your mouse over me for a few seconds to see the dynamically bound title!&lt;/span&gt;

class HoverExample {
  mySpan = {
    attr: { title: &quot;&quot; }
  };

  onMySpanHover = new IXEvent();
}

let form = IX.CreateProxy(new HoverExample());
form
  .onMySpanHover
  .Add(() =&gt; 
    hform.mySpan.attr.title = `You loaded this page on ${new Date().toLocaleString()}`);</pre>
<p>More verbose but the benefit is that you're using a repeatable pattern of 
using a multicast event handler.&nbsp; I did have an implementation where I 
could just set the title as a function, but I didn't like the one-off 
implementation behind the scenes that this required.</p>
<h2><a name="Conditionals15">Conditionals</a></h2>
<p>I also really don't like to make a mess of the markup with declarative code 
elements.</p>
<h3><a name="TheVueWay16">The Vue Way</a></h3>
<pre>&lt;div id=&quot;app-3&quot;&gt;
  &lt;span v-if=&quot;seen&quot;&gt;Now you see me&lt;/span&gt;
&lt;/div&gt;

var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})</pre>
<h3><a name="TheIXWay17">The IX Way</a></h3>
<p>In IX, conditional behaviors are implemented through the event mechanism, 
usually to manipulate element attributes.&nbsp; Diverging slightly from the Vue 
example above, note the addition of two buttons to toggle the visibility of the <code>SPAN</code>:</p>
<pre>&lt;span id=&quot;seen&quot;&gt;Now you see me...&lt;/span&gt;
 &lt;!-- Two ways to declare a button --&gt;
&lt;button id=&quot;show&quot;&gt;Show&lt;/button&gt;
&lt;input id=&quot;hide&quot; type=&quot;button&quot; value=&quot;Hide&quot; /&gt;


class VisibilityExample {
  seen = {
    attr: { visible: true }
  };


  onShowClicked = new IXEvent().Add((_, p) =&gt; p.seen.attr.visible = true);
  onHideClicked = new IXEvent().Add((_, p) =&gt; p.seen.attr.visible = false);
}

IX.CreateProxy(new VisibilityExample());</pre>
<p>These are wired up to two buttons, hence the event handlers.</p>
<p>Here:</p>
<ol>
	<li>We have a consistent way of manipulating element attributes.</li>
	<li>Intellisense works perfectly in Visual Studio.</li>
	<li>No &quot;string&quot; element name.</li>
</ol>
<h2><a name="Loops18">Loops</a></h2>
<h3><a name="TheVueWay19">The Vue Way</a></h3>
<pre>&lt;div id=&quot;app-4&quot;&gt;
  &lt;ol&gt;
    &lt;li v-for=&quot;todo in todos&quot;&gt;
      {{ todo.text }}
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: 'Learn JavaScript' },
      { text: 'Learn Vue' },
      { text: 'Build something awesome' }
    ]
  }
})</pre>
<h3><a name="TheIXWay20">The IX Way</a></h3>
<pre>&lt;ol id=&quot;someList&quot;&gt;&lt;/ol&gt;

class ListExample {
  someList: string[] = [&quot;Learn Javascript&quot;, &quot;Learn IX&quot;, &quot;Wear a mask!&quot;];
}

IX.CreateProxy(new ListExample());</pre>
<p>Result:</p>
<p><img border="0" src="loop1.png" width="152" height="91"></p>
<p>Given that most lists come from a data source rather being hard coded:</p>
<pre>&lt;ol id=&quot;someList&quot;&gt;&lt;/ol&gt;

class ListExample {
  someList: string[] = [];
}

let listForm = IX.CreateProxy(new ListExample());

listForm.someList.push(&quot;Learn Javascript&quot;);
listForm.someList.push(&quot;Learn IX&quot;);
listForm.someList.push(&quot;Wear a mask!&quot;);</pre>
<p>Or:</p>
<pre>let listForm = IX.CreateProxy(new ListExample());
let items = [&quot;Learn Javascript&quot;, &quot;Learn IX&quot;, &quot;Wear a mask!&quot;];
listForm.someList = items;</pre>
<h2><a name="ButtonClicks21">Button Clicks</a></h2>
<h3><a name="TheVueWay22">The Vue Way</a></h3>
<pre>&lt;div id=&quot;app-5&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

var app5 = new Vue({
  el: '#app-5',
  data: {
  message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})</pre>
<h3><a name="TheIXWay23">The IX Way</a></h3>
<pre>&lt;div&gt;
  &lt;p id=&quot;message&quot;&gt;&lt;/p&gt;
  &lt;button id=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

class ReverseExample {
  message = &quot;Hello From Interacx!&quot;;
  onReverseMessageClicked = new IXEvent()
    .Add((_, p: ReverseExample) =&gt; p.message = p.message.split('').reverse().join(''));
}

IX.CreateProxy(new ReverseExample());</pre>
<p>Again, notice:</p>
<ol>
	<li>No &quot;Mustache&quot; {{ }} syntax required.</li>
<li>No &quot;#id&quot; string to identify the element ID.</li>
	<li>The event mechanism, being multicast, allows us to wire up more than one 
	event (not illustrated, but that's point of using events.)</li>
</ol>
<p><img border="0" src="r1.png" width="170" height="54"></p>
<p>After clicking on the button:</p>
<p><img border="0" src="r2.png" width="161" height="52"></p>
<h2><a name="DataConversion24">Data Conversion</a></h2>
<p>The following example is similar to Vue's <code>.number</code> attribute but the actual 
implementation is much more general purpose.</p>
<p>Consider this UI:</p>
<p><img border="0" src="convert.png" width="548" height="52"></p>
<p>And the markup (CSS and extraneous DIV's removed for readability):</p>
<pre>X:
&lt;input id=&quot;x&quot; class=&quot;fieldInputSmall&quot; /&gt;
Y:
&lt;input id=&quot;y&quot; class=&quot;fieldInputSmall&quot; /&gt;</pre>
<p>Here, we do not want the strings &quot;1&quot; and &quot;2&quot; to sum to &quot;12&quot;, so we implement 
converters:</p>
<pre>class InputForm {
  x: number;
  y: number;

  onXChanged = new IXEvent();
  onYChanged = new IXEvent();

  // Converters, so 1 + 2 != '12'
  onConvertX = x =&gt; Number(x);
  onConvertY = y =&gt; Number(y);

  Add = () =&gt; this.x + this.y;
}

class OutputForm {
  sum: number;
}
</pre>
<p>And the events are wired up like this:</p>
<pre>let inputForm = IX.CreateProxy(new InputForm());
let outputForm = IX.CreateProxy(new OutputForm());

inputForm.onXChanged.Add(() =&gt; outputForm.sum = inputForm.Add());
inputForm.onYChanged.Add(() =&gt; outputForm.sum = inputForm.Add());</pre>
<p>Behind the scenes, the input box text is converted to a <code>Number</code> with the 
<code>onConvertX</code> and <code>onConvertY</code> converters, and the rest is handled by the standard 
data binding of the properties for setting <code>sum</code> to the values of </code>x</code> and </code>y</code>.</p>
<p>Also, notice how you can create classes as containers to sections of the HTML.&nbsp; 
We could easily have put <code>sum</code> in the <code>InputForm</code>, but instead I wanted to 
illustrate how to use a separate container object, <code>OutputForm</code>, as a way of 
compartmentalizing the properties into separate containers.</p>
<h2><a name="TwoWayBinding25">Two Way Binding</a></h2>
<p>We've already seen in the examples above binding between the view and the 
model.&nbsp; One of Vue's examples is direct update of one element based on the 
realtime update of an input element.&nbsp; While I can't think of a real-life 
example where one would need this, real-time updating, say of a filter criteria, 
is definitely useful, so we'll start with the Vue example:</p>
<h3><a name="TheVueWay26">The Vue Way</a></h3>
<pre>&lt;div id=&quot;app-6&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
    &lt;input v-model=&quot;message&quot;&gt;
  &lt;/div&gt;

var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})</pre>
<h3><a name="TheIXWay27">The IX Way</a></h3>
<p>This is already easily accomplished with events:</p>
<pre>First Name:
&lt;p id=&quot;message2&quot;&gt;/p&gt;
&lt;input id=&quot;input2&quot;/&gt;

class BidirectionalExample {
  message2: string = &quot;&quot;;
  input2: string = &quot;&quot;;

  onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}

IX.CreateProxy(new BidirectionalExample());</pre>
<p><img border="0" src="keyUp.png" width="171" height="48"></p>
<p>However, to make this more &quot;Vue-ish&quot;, we can do:</p>
<pre>class BidirectionalExample {
  message2 = new IXBinder({ input2: null });
  input2: string = &quot;&quot;;</pre>
<p>Here we are specifying the &quot;from&quot; element as the key and any &quot;value&quot; of the 
key.&nbsp; What displeases me about this is that the key cannot be implemented a 
way that leverages Intellisense and type checking.&nbsp; The best we can do is 
runtime checking that the &quot;from&quot; binder element exists.&nbsp; So at this point, 
specifying the &quot;bind from&quot; property as a string almost makes sense.&nbsp; 
Instead, I opted for this implementation:</p>
<pre>class BidirectionalExample {
  input2: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}</pre>
<p>Which is somewhat lame as well but has the advantage of supporting 
Intellisense, albeit the property your binding to must already be declared 
previously.&nbsp; Behind the scenes, we have a very simple implementation to 
extract the name, by converting the function into a string:</p>
<pre>public static nameof&lt;TResult&gt;(name: () =&gt; TResult): string {
  let ret = IX.RightOf(name.toString(), &quot;.&quot;);

  return ret;
}</pre>
<p>Sadly that's seems to be the best we can do with Javascript unless you want 
to use something like <a href="https://github.com/dsherret/ts-nameof">ts-nameof</a>, 
which I do not because ts-nameof is a compile-time transformation, and I do not 
want the developer that uses this library to have to go through hoops to get 
this to work.</p>
<p>We can also bind the same source to different targets:</p>
<pre>&lt;p&gt;
  &lt;label id=&quot;message2&quot;&gt;&lt;/label&gt;
  &lt;label id=&quot;message3&quot;&gt;&lt;/label&gt;
&lt;/p&gt;
&lt;input id=&quot;input2&quot; /&gt;

class BidirectionalExample {
  input2: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
}</pre>
<p>As well as different sources to the same target:</p>
<pre>&lt;p&gt;
  &lt;label id=&quot;message2&quot;&gt;&lt;/label&gt;
  &lt;label id=&quot;message3&quot;&gt;&lt;/label&gt;
&lt;/p&gt;
&lt;input id=&quot;input2&quot; /&gt;
&lt;input id=&quot;input3&quot; /&gt;

class BidirectionalExample {
  input2: string = &quot;&quot;;
  input3: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) })
               .Add({ bindFrom: IX.nameof(() =&gt; this.input3) });
}</pre>
<p>Here, typing in the left edit box sets messages 2 &amp; 3:</p>
<p><img border="0" src="src1.png" width="326" height="51"></p>
<p>Typing in the right edit box sets message 3:</p>
<p><img border="0" src="src2.png" width="324" height="51"></p>
<p>But as I said earlier, doing this kind of binding really doesn't make much 
sense.&nbsp; Typically, a transformation does something &quot;useful&quot;, so we have 
this contrived example:</p>
<pre>class BidirectionalExample {
  input2: string = &quot;&quot;;
  input3: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) }).Add({
    bindFrom: IX.nameof(() =&gt; this.input3), 
    op: v =&gt; v.split('').reverse().join('') 
  });

// onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}</pre>
<p>and thus we get:</p>
<p><img border="0" src="op1.png" width="313" height="49"></p>
<h2><a name="Checkboxes28">Checkboxes</a></h2>
<h3><a name="BindingCheckboxState29">Binding Checkbox State</a></h3>
<h4><a name="TheVueWay30">The Vue Way</a></h4>
<p>Vue has an elegant demonstration of binding the checkbox state to the label:</p>
<pre>&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;</pre>
<h4><a name="TheIXWay31">The IX Way</a></h4>
<p>Given:</p>
<pre>&lt;input id=&quot;checkbox&quot; type=&quot;checkbox&quot; /&gt;
&lt;label id=&quot;ckLabel&quot; for=&quot;checkbox&quot;&gt;&lt;/label&gt;</pre>
<p>We continue to follow the pattern of using TypeScript classes and properties:</p>
<pre>class CheckboxExample {
  checkbox: boolean = false;
  ckLabel = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.checkbox) });
}

IX.CreateProxy(new CheckboxExample());</pre>
<p>or, because the nameof syntax above is clumsy and we don't have a real &quot;nameof&quot; 
operator in Javascript by the time the code is transpiled, so we have to revert 
to string literals in this case:</p>
<pre>class CheckboxExample {
  checkbox: boolean = false;
  ckLabel = new IXBinder({ bindFrom: &quot;checkbox&quot; });
}

IX.CreateProxy(new CheckboxExample());</pre>
<p><img border="0" src="ckfalse.png" width="56" height="28"></p>
<p><img border="0" src="cktrue.png" width="58" height="27"></p>
<p>Or we can wire up the click event:</p>
<pre>class CheckboxExample {
  checkbox: boolean = false;
  ckLabel: string = &quot;Unchecked&quot;;

  onCheckboxClicked = 
    new IXEvent().Add(
      (_, p: CheckboxExample) =&gt; 
          p.ckLabel = p.checkbox ? &quot;Checked&quot; : &quot;Unchecked&quot;);
}

IX.CreateProxy(new CheckboxExample());</pre>
<p><img border="0" src="ckunchecked.png" width="94" height="27"></p>
<p><img border="0" src="ckchecked.png" width="87" height="29"></p>
<h3><a name="BindingCheckboxValues32">Binding Checkbox Values</a></h3>
<h4><a name="TheViewWay33">The View Way</a></h4>
<pre>&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;</pre>
<p>Note that the span text includes the array brackets:</p>
<p><img border="0" src="viewckarray.png" width="251" height="69"></p>
<h4><a name="TheIXWay34">The IX Way</a></h4>
<p>Given:</p>
<pre>&lt;input id=&quot;jane&quot; value=&quot;Jane&quot; type=&quot;checkbox&quot; /&gt;
&lt;label for=&quot;jane&quot;&gt;Jane&lt;/label&gt;
&lt;input id=&quot;mary&quot; value=&quot;Mary&quot; type=&quot;checkbox&quot; /&gt;
&lt;label for=&quot;mary&quot;&gt;Mary&lt;/label&gt;
&lt;input id=&quot;grace&quot; value=&quot;Grace&quot; type=&quot;checkbox&quot; /&gt;
&lt;label for=&quot;grace&quot;&gt;Grace&lt;/label&gt;
&lt;br /&gt;
&lt;label id=&quot;ckNames&quot;&gt;&lt;/label&gt;</pre>
<p>We implement the container object with a special array binding (because the 
properties don't exist in the class, I can't use the &quot;nameof&quot; kludge, so the 
ID&quot;s are, sadly, string literals.)&nbsp; Of course, in the next example, I do 
have properties for the checkboxes, but I still used the string literals!</p>
<pre>class CheckboxListExample {
  ckNames = IXBinder.AsArray(items =&gt; items.join(&quot;, &quot;))
    .Add({ bindFrom: &quot;jane&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;mary&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;grace&quot;, attribute: &quot;value&quot; });
}

IX.CreateProxy(new CheckboxListExample());</pre>
<p>And we get:</p>
<p><img border="0" src="ixckarray.png" width="191" height="55"></p>
<p>Notice that we did not initialize properties with the checkbox state!&nbsp; 
If we do this:</p>
<pre>class CheckboxListExample {
  jane: boolean = false;
  mary: boolean = false;
  grace: boolean = false;
  ckNames = IXBinder.AsArray(items =&gt; items.join(&quot;, &quot;))
    .Add({ bindFrom: &quot;jane&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;mary&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;grace&quot;, attribute: &quot;value&quot; });
}

let ckListExample = IX.CreateProxy(new CheckboxListExample());</pre>
<p>We can programmatically set the check state:</p>
<pre>ckListExample.jane = true;
ckListExample.mary = true;</pre>
<p>and we see:</p>
<p><img border="0" src="cklistprog.png" width="180" height="50"></p>
<p>So one thing we note here is that the property referring to the HTML element 
is associated <i>with the checked attribute of the element</i>.&nbsp; That is an 
artifact of how IX is coded, and actually points out an interesting problem -- 
the object property maps to only one attribute of the DOM element, and IX is 
very opinionated as to what that DOM element should be, depending on what the 
element is!</p>
<h2><a name="RadioButtons35">Radio Buttons</a></h2>
<h3><a name="TheViewWay36">The View Way</a></h3>
<p>This example binds the value of the radio button to the span:</p>
<pre>&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
&lt;br&gt;
&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Picked: {{ picked }}&lt;/span&gt;</pre>
<h3><a name="TheIXWay37">The IX Way</a></h3>
<p>Given:</p>
<pre>&lt;input id=&quot;marc&quot; value=&quot;Marc&quot; type=&quot;radio&quot; name=&quot;group1&quot; /&gt;
&lt;label for=&quot;marc&quot;&gt;Marc&lt;/label&gt;
&lt;input id=&quot;chris&quot; value=&quot;Chris&quot; type=&quot;radio&quot; name=&quot;group1&quot; /&gt;
&lt;label for=&quot;chris&quot;&gt;Chris&lt;/label&gt;
&lt;br /&gt;
&lt;label id=&quot;rbPicked&quot;&gt;&lt;/label&gt;</pre>
<p>We add two binders, whichever one is clicked becomes the one whose binder 
event is fired.&nbsp; Again, note in this example I'm not using the &quot;nameof&quot; 
syntax because in this case the property doesn't exist!</p>
<pre>class RadioExample {
  rbPicked = new IXBinder({ bindFrom: &quot;marc&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;chris&quot;, attribute: &quot;value&quot; });
}

IX.CreateProxy(new RadioExample());</pre>
<p>thus updating to the current radio button:</p>
<p><img border="0" src="rb1.png" width="132" height="48"></p>
<p><img border="0" src="rb2.png" width="120" height="43"></p>
<p>And if we want to programmatically set the radio button state, define the 
properties:</p>
<pre>class RadioExample {
  marc: boolean = false;
  chris: boolean = false;
  rbPicked = new IXBinder({ bindFrom: &quot;marc&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;chris&quot;, attribute: &quot;value&quot; });
}</pre>
<p>and after proxy initialization, set the state:</p>
<pre>let rbExample = IX.CreateProxy(new RadioExample());
rbExample.chris = true;</pre>
<p><img border="0" src="rb2.png" width="120" height="43"></p>
<h2><a name="ComboBoxes38">ComboBoxes</a></h2>
<h3><a name="TheVueWay39">The Vue Way</a></h3>
<pre>&lt;select v-model=&quot;selected&quot;&gt;
  &lt;option disabled value=&quot;&quot;&gt;Please select one&lt;/option&gt;
  &lt;option&gt;A&lt;/option&gt;
  &lt;option&gt;B&lt;/option&gt;
  &lt;option&gt;C&lt;/option&gt;
&lt;/select&gt;
&lt;span&gt;Selected: {{ selected }}&lt;/span&gt;</pre>
<h3><a name="TheIXWay40">The IX Way</a></h3>
<p>Given:</p>
<pre>&lt;select id=&quot;selector&quot;&gt;
  &lt;option selected disabled&gt;Please select one&lt;/option&gt;
  &lt;option value=&quot;1&quot;&gt;A&lt;/option&gt;
  &lt;option value=&quot;2&quot;&gt;B&lt;/option&gt;
  &lt;option value=&quot;3&quot;&gt;C&lt;/option&gt;
&lt;/select&gt;
&lt;br /&gt;
&lt;span id=&quot;selection&quot;&gt;&lt;/span&gt;</pre>
<p>and the container class:</p>
<pre>class ComboboxExample {
  selector = new IXSelector();
  selection: string = &quot;&quot;;

  onSelectorChanged = 
    new IXEvent().Add((_, p) =&gt; 
      p.selection = `Selected: ${p.selector.text} with value ${p.selector.value}`);
}

IX.CreateProxy(new ComboboxExample());</pre>
<p>We then see:</p>
<p><img border="0" src="select1.png" width="129" height="28"></p>
<p>and after selection:</p>
<p><img border="0" src="select2.png" width="156" height="45"></p>
<p>Note that the selector property, implemented as an <code>IXSelector</code>, contains two 
properties, <code>text</code> and <code>value</code>, for the selected item.</p>
<p>We can also initialize the options programmatically.&nbsp; Given:</p>
<pre>&lt;select id=&quot;selector2&quot;&gt;&lt;/select&gt;
&lt;br /&gt;
&lt;span id=&quot;selection2&quot;&gt;&lt;/span&gt;</pre>
<p>and:</p>
<pre>class ComboboxInitializationExample {
  selector2 = new IXSelector().Add({ selected:true, disabled: true, text: &quot;Please select one&quot; })
    .Add({ value: 12, text: &quot;AAA&quot; })
    .Add({ value: 23, text: &quot;BBB&quot; })
    .Add({ value: 34, text: &quot;CCC&quot; });

  selection2: string = &quot;&quot;;

  onSelector2Changed = new IXEvent().Add((_, p) =&gt; p.selection2 = `Selected: ${p.selector2.text} with value ${p.selector2.value}`);
}

 let cb = IX.CreateProxy(new ComboboxInitializationExample());</pre>
<p>We see:</p>
<p><img border="0" src="select3.png" width="184" height="42"></p>
<p>And programmatically set the selection with the option value:</p>
<pre>cb.selector2.value = 34;</pre>
<p><img border="0" src="select4.png" width="189" height="45"></p>
<p>or with the option text:</p>
<pre>cb.selector2.text = &quot;AAA&quot;;</pre>
<pre><img border="0" src="select5.png" width="182" height="45"></pre>
<p>Or add to the list of options:</p>
<pre>cb.selector2.options.push({ text: &quot;DDD&quot;, value: 45 });</pre>
<p><img border="0" src="select6.png" width="127" height="187"></p>
<p>Or remove the option item:</p>
<pre>cb.selector2.options.pop();</pre>
<pre><img border="0" src="selector7.png" width="133" height="119"></pre>
<p>Or change an option's text and value:</p>
<pre>cb.selector2.options[2] = { text: &quot;bbb&quot;, value: 999 };</pre>
<p><img border="0" src="selector8.png" width="124" height="154"></p>
<h2><a name="ImplementationPatterns41">Implementation Patterns</a></h2>
<p>IX requires that class properties match the DOM element ID and that event 
handlers have specific signatures.</p>
<h3><a name="IDandClassPropertyName42">ID and Class Property Name</a></h3>
<p><img border="0" src="idprop1.png" width="405" height="115"></p>
<h3><a name="KeyUp,Changed,andConvertEvents43">KeyUp, Changed, and Convert Events</a></h3>
<p><img border="0" src="idprop2.png" width="368" height="152"></p>
<p>Notice:</p>
<p>The event name uses the property name with the first letter capitalized, 
	so <code>firstName</code> becomes <code>FirstName</code>.</p>
<h3><a name="SupportedEvents44">Supported Events</a></h3>
<h4><a name="KeyUp45">KeyUp</a></h4>
<p>on[Prop]KeyUp - realtime key up events.</p>
<h4><a name="Changed46">Changed</a></h4>
<p>on[Prop]Changed - element loses focus.</p>
<p>This event applies to text, radio and checkbox inputs and &quot;select&quot; (combobox) 
elements.</p>
<h4><a name="Convert47">Convert</a></h4>
<p>onConvert[Prop] - if defined, executes the function before the KeyUp and 
Changed events fire.</p>
<h4><a name="Hover48">Hover</a></h4>
<p>on[Prop]Hover - if defined and the property has the signature:</p>
<pre>{
  attr: { title: &quot;&quot; }
};</pre>
<p>This will set the element's title on mouse hover.</p>
<h2><a name="IntegrationTests49">Integration Tests</a></h2>
<p><img border="0" src="tests.png" width="257" height="302"></p>
<p>We can easily test the behavior of IX by directly inspecting DOM elements 
after model changes, and vice versa.&nbsp; And I prefer to use the phrase 
&quot;integration test&quot; rather than &quot;unit test&quot; because we're not testing low level 
functions in the IX library -- we are testing the integration of the DOM 
elements with object properties.&nbsp; </p>
<p>The HTML for the test cases is simple:</p>
<pre>&lt;div id=&quot;testResults&quot; class=&quot;inline&quot; style=&quot;min-width:600px&quot;&gt;
  &lt;ol id=&quot;tests&quot;&gt;&lt;/ol&gt;
&lt;/div&gt;

&lt;div id=&quot;testDom&quot;&gt;&lt;/div&gt;</pre>
<p>We have an ordered list for the test results, and a <code>div</code> in which we place the 
HTML required for each test.</p>
<h3><a name="TheTestRunner50">The Test Runner</a></h3>
<p>The tests actually use IX to manipulate the test results, and direct DOM 
manipulation to simulate UI changes.&nbsp; The runner looks like this:</p>
<pre>let testForm = IX.CreateProxy(new TestResults());
let idx = 0;

tests.forEach(test =&gt; {
  // Get just the name of the test function.
  let testName = IX.LeftOf(test.testFnc.toString(), &quot;(&quot;);

  // The ID will start with a lowercase letter
  let id = IX.LowerCaseFirstChar(testName);

  // Push a template to OL, where the template value is simply the test name, to the test results ordered list.
  testForm.tests.push(IXTemplate.Create({ value: testName, id: id }));

  // Create an object with the id and proxy it. This will match the id of the template we just created, so we can set its style.
  // This is a great example of not actually needing to create a class, which is really
  // just a dictionary.
  let obj = {};

  // The classList here allows us to set the test LI element style class to indicate success/failure of the test.
  obj[id] = { classList: new IXClassList() }; 
  let testProxy = IX.CreateProxy(obj);

  // Create the DOM needed for the test.
  this.CreateTestDom(testForm, test.dom);

  // Run the test and indicate the result.
  this.RunTest(testForm, idx, testProxy, test, id);

  // Remove the DOM needed for the test.
  this.RemoveTestDom(testForm);

  ++idx;
});</pre>
<p>And we have these three helper functions:</p>
<pre>CreateTestDom(testForm: TestResults, testDom: string): void {
  testForm.testDom = testDom || &quot;&quot;;
}

RemoveTestDom(testForm: TestResults, ): void {
  testForm.testDom = &quot;&quot;;
}

RunTest(testForm: TestResults, idx:number, testProxy: object, test, id: string): void {
  let passFail = &quot;pass&quot;;

  try {
    test.testFnc(test.obj, id);
  } catch (err) {
    passFail = &quot;fail&quot;;
    let template = testForm.tests[idx];
    template.SetValue(`${template.value} =&gt; ${err}`);
  }

  testProxy[id].classList.Add(passFail);
}</pre>
<p>A passing test is indicated in green, a failing test in red, along with the 
error message.</p>
<pre>.pass {
  color: green;
}

.fail {
  color: red;
}</pre>
<p>So for example, we can test that failure are handled:</p>
<pre>static ShouldFail(obj): void {
  throw &quot;Failed!!!&quot;;
}</pre>
<p>And we see:</p>
<p><img border="0" src="failed.png" width="173" height="25"></p>
<h3><a name="DefiningtheTests51">Defining the Tests</a></h3>
<p>The tests are defined as an array of objects the specify:</p>
<ol>
	<li>The test to be run.</li>
	<li>The &quot;object&quot; being manipulated in the test.</li>
	<li>The HTML to support the test.</li>
</ol>
<p>Like this:</p>
<pre>let tests = [
  // { testFnc: IntegrationTests.ShouldFail },
  { testFnc: IntegrationTests.InputElementSetOnInitializationTest, obj: { inputTest: &quot;Test&quot; }, dom: &quot;&lt;input id='inputTest'/&gt;&quot; },
  { testFnc: IntegrationTests.InputElementSetOnAssignmentTest, obj: { inputTest: &quot;&quot; }, dom: &quot;&lt;input id='inputTest'/&gt;&quot; },
  { testFnc: IntegrationTests.InputSetsPropertyTest, obj: { inputTest: &quot;&quot; }, dom: &quot;&lt;input id='inputTest'/&gt;&quot; },
  { testFnc: IntegrationTests.ListInitializedTest, obj: { list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] }, dom: &quot;&lt;ol id='list'&gt;&lt;/ol&gt;&quot; },
  { testFnc: IntegrationTests.ReplaceInitializedTest, obj: { list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] }, dom: &quot;&lt;ol id='list'&gt;&lt;/ol&gt;&quot; },
  { testFnc: IntegrationTests.ChangeListItemTest, obj: { list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] }, dom: &quot;&lt;ol id='list'&gt;&lt;/ol&gt;&quot; },
  { testFnc: IntegrationTests.PushListItemTest, obj: { list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] }, dom: &quot;&lt;ol id='list'&gt;&lt;/ol&gt;&quot; },
  { testFnc: IntegrationTests.PopListItemTest, obj: { list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] }, dom: &quot;&lt;ol id='list'&gt;&lt;/ol&gt;&quot; },
  {
    testFnc: IntegrationTests.ButtonClickTest,
    obj: { clicked: false, onButtonClicked : new IXEvent().Add((_, p) =&gt; p.clicked = true)},
    dom: &quot;&lt;button id='button'&gt;&lt;/button&gt;&quot;
  },
  {
    testFnc: IntegrationTests.OnlyOneClickEventTest,
    obj: { clicked: 0, onButtonClicked: new IXEvent().Add((_, p) =&gt; p.clicked += 1) },
    dom: &quot;&lt;button id='button'&gt;&lt;/button&gt;&quot;
  },
  {
    testFnc: IntegrationTests.CheckboxClickTest,
    obj: { clicked: false, checkbox: false, onCheckboxClicked: new IXEvent().Add((_, p) =&gt; p.clicked = p.checkbox)},
    dom: &quot;&lt;input id='checkbox' type='checkbox'/&gt;&quot;
  },
  {
    testFnc: IntegrationTests.RadioButtonClickTest,
    obj: { clicked: false, checkbox: false, onRadioClicked: new IXEvent().Add((_, p) =&gt; p.clicked = p.radio) },
    dom: &quot;&lt;input id='radio' type='radio'/&gt;&quot;
  },
  {
    testFnc: IntegrationTests.ConvertTest,
    obj: { inputTest: &quot;&quot;, onConvertInputTest: s =&gt; `${s} Converted!` },
    dom: &quot;&lt;input id='inputTest'/&gt;&quot;
  },
  { testFnc: IntegrationTests.VisibleAttributeTest, obj: { inputTest: { attr: { visible: true } } }, dom: &quot;&lt;input id='inputTest'/&gt;&quot; },
  { testFnc: IntegrationTests.ControlBindingTest, obj: { input: &quot;123&quot;, output: new IXBinder({ bindFrom: &quot;input&quot; }) }, dom: &quot;&lt;input id='input'&gt;&lt;p id='output'&gt;&quot; },
  { testFnc: IntegrationTests.ControlBindingWithOperationTest, obj: { input: &quot;123&quot;, output: new IXBinder({ bindFrom: &quot;input&quot;, op: v =&gt; `${v} Operated!` }) }, dom: &quot;&lt;input id='input'&gt;&lt;p id='output'&gt;&quot; },
  { testFnc: IntegrationTests.ControlBindingAssignmentTest, obj: { input: &quot;&quot;, output: new IXBinder({ bindFrom: &quot;input&quot; }) }, dom: &quot;&lt;input id='input'&gt;&lt;p id='output'&gt;&quot; },
];</pre>
<p>I'm not going to bore you with the actual tests, but I'll point out that in 
some cases we have to simulate clicking and therefore the test must dispatch the 
appropriate event, for example:</p>
<pre>static ButtonClickTest(obj): void {
  let test = IX.CreateProxy(obj);
  let el = document.getElementById(&quot;button&quot;) as HTMLButtonElement;
  el.dispatchEvent(new Event('click')); 
  IXAssert.Equal(test.clicked, true);
}</pre>
<h3><a name="TheIXAssertHelper52">The IXAssert Helper</a></h3>
<p>This class simply wraps the <code>if</code> statement into a one-liner, as I rather 
dislike <code>if</code> statements for assertions.</p>
<pre>export class IXAssert {
  public static Equal(got: any, expected: any): void {
    let b = got == expected;

    if (!b) {
      throw `Expected ${expected}, got ${got}`;
    }
  }

  public static IsTrue(b: boolean): void {
    if (!b) {
      throw &quot;Not true&quot;;
    }
  }
}</pre>
<h3><a name="YouDon'tNeedTypeScriptClasses53">You Don't Need TypeScript Classes</a></h3>
<p>You should realize from looking at how the tests are implemented that you 
don't need actual TypeScript classes, you just need an object, like <code>obj: { inputTest: "Test" }</code> - after all, 
a TypeScript class is a purely development-side construct used for type checking 
and Intellisense by the IDE.&nbsp; Even a JavaScript class is really just 
&quot;syntactical sugar of JavaScript's existing prototype-based inheritance.&quot; (<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">JavaScript 
classes</a>)</p>
<h2><a name="BehindtheScenes54">Behind the Scenes</a></h2>
<h3><a name="TypeScriptDoesNotMeanRuntimeTypeReflection55">TypeScript Does Not Mean Runtime Type Reflection</a></h3>
<p>TypeScript is fantastic for ensuring type safety when <i>writing</i> code.&nbsp; 
However, by the time the code has been transpiled to JavasScript, all that type 
information that the IDE is using is of course lost.&nbsp; This is unfortunate 
because there are times in the code that I really wish I had type information.&nbsp; 
There are some workarounds, such as for native types and classes:</p>
<pre>let a = 1;
let b = &quot;foo&quot;;
let c = true;
let d = [];
let e = new SomeClass();
[a, b, c, d, e].forEach(q =&gt; console.log(q.constructor.name));

let listForm = IX.CreateProxy(new ListExample());</pre>
<p>You get:</p>
<p><img border="0" src="objects2.png" width="80" height="78"></p>
<p>This is useful.&nbsp; However, given this class:</p>
<pre>class SomeClass {
  a: number;
  b: string;
}</pre>
<p>What that gets transpiled to is simply an empty object <code>{}</code>.&nbsp; 
So, <code>Object.keys(new SomeClass())</code> return an empty array <code>[]</code>.&nbsp; 
To determine properties of the class, the properties must be initialized, and 
they can even be initialized to null or undefined:</p>
<pre>class SomeClass {
  a: number = null;
  b: string = undefined;
}</pre>
<p><img border="0" src="objects1.png" width="455" height="69"></p>
<p>Hence the constraint in IX that you must initialize properties, otherwise the 
wire-up cannot be made between the class property and the element with the ID of 
the property name.</p>
<h3><a name="ProxyInitialization56">Proxy Initialization</a></h3>
<pre>public static CreateProxy&lt;T&gt;(container: T): T {
  let proxy = new Proxy(container, IX.uiHandler);
  IX.CreatePropertyHandlers(container, proxy);
  IX.CreateButtonHandlers(container, proxy);
  IX.CreateBinders(container, proxy);
  IX.Initialize(container, proxy);

  return proxy;
}</pre>
<p>Besides instantiating the proxy, we can see that several other steps are 
required:</p>
<ol>
	<li>Special property handlers.</li>
	<li>Button handlers.</li>
	<li>Binders.</li>
	<li>Final initialization.</li>
</ol>
<h4><a name="CreatePropertyHandlers57">CreatePropertyHandlers</a></h4>
<p>This code is intended to handle attributes, class lists, and event wireups.&nbsp; 
Events are only wired up once, in case the proxy is re-initialized after class 
property assignments.&nbsp; To make matters a bit more complicated, specific 
cases are handled here, such as proxy'ing the <code>attr</code> key to 
accommodate the custom syntax for assigning attributes to the associated DOM 
element.&nbsp; The <code>class</code> attribute is handled similarly, creating a 
proxy for the <code>classList</code> key.&nbsp; A better implementation is 
discussed in the conclusion.&nbsp; Otherwise, the initial purpose of the 
function was solely to handle the <code>mouseover</code>, <code>change</code>, and <code>keyup</code> events.</p>
<pre>private static CreatePropertyHandlers&lt;T&gt;(container: T, proxy: T) {
  Object.keys(container).forEach(k =&gt; {
  let el = document.getElementById(k);
  let anonEl = el as any;

  // If element exists and we haven't assigned a proxy to the container's field, then wire up the events.
  if (el &amp;&amp; !anonEl._proxy) {
    anonEl._proxy = this;

    if (container[k].attr) {
      // Proxy the attributes of the container so we can intercept the setter for attributes
      console.log(`Creating proxy for attr ${k}`);
      container[k].attr = IXAttributeProxy.Create(k, container[k].attr);
    }

    if (container[k].classList) {
      console.log(`Creating proxy for classList ${k}`);
      container[k].classList = IXClassListProxy.Create(k, container[k].classList);
    }

    let idName = IX.UpperCaseFirstChar(el.id);

    // TODO: create a dictionary to handle this.
    let changedEvent = `on${idName}Changed`;
    let hoverEvent = `on${idName}Hover`;
    let keyUpEvent = `on${idName}KeyUp`;

    if (container[hoverEvent]) {
      IX.WireUpEventHandler(el, container, proxy, null, &quot;mouseover&quot;, hoverEvent);
    }

    // Change event is always wired up so we set the container's value when the UI element value changes.
    switch (el.nodeName) {
      case &quot;SELECT&quot;:
      case &quot;INPUT&quot;:
        // TODO: If this is a button type, then what?
        IX.WireUpEventHandler(el, container, proxy, &quot;value&quot;, &quot;change&quot;, changedEvent);
      break;
    }

    if (container[keyUpEvent]) {
      switch (el.nodeName) {
        case &quot;INPUT&quot;:
          // TODO: If this is a button type, then what?
          IX.WireUpEventHandler(el, container, proxy, &quot;value&quot;, &quot;keyup&quot;, keyUpEvent);
          break;
        }
      }
    }
  });
}</pre>
<p>It should be obvious that this a very incomplete implementation sufficient 
for the proof-of-concept.</p>
<h4><a name="WireUpEventHandler58">WireUpEventHandler</a></h4>
<p>The event handler that is attached the event listener implements a custom 
check for the <code>SELECT</code> HTML element and makes the assumption that the class 
property has been initialized with an <code>IXSelector</code> instance.&nbsp; 
This was done so that the selected item's text and value could be assigned on 
selection to the <code>IXSelector</code> instance.&nbsp; Otherwise, the event 
handler updates the class' property (as in, the class that has been proxied.)&nbsp; 
Because &quot;buttons&quot; don't have a property but are just an event, we check if there 
is actually a property on the DOM that needs to be read and set on the 
corresponding class property.&nbsp; Lastly, if the class implements an event 
handler, any multicast events are fired.&nbsp; A custom converter, if defined in 
the class, is invoked first for non-button events.</p>
<pre>private static WireUpEventHandler&lt;T&gt;(el: HTMLElement, container: T, proxy: T, propertyName: string, eventName: string, handlerName: string) {
  el.addEventListener(eventName, ev =&gt; {
    let el = ev.srcElement as HTMLElement;
    let oldVal = undefined;
    let newVal = undefined;
    let propName = undefined;
    let handler = container[handlerName];

    switch (el.nodeName) {
      case &quot;SELECT&quot;:
        let elSelector = el as HTMLSelectElement;
        let selector = container[el.id] as IXSelector;
        selector.value = elSelector.value;
        selector.text = elSelector.options[elSelector.selectedIndex].text;
        break;

      default:
        // buttons are click events, not change properties.
        if (propertyName) {
          oldVal = container[el.id];
          newVal = el[propertyName];
          propName = el.id;
        }

        let ucPropName = IX.UpperCaseFirstChar(propName ?? &quot;&quot;);

        if (propertyName) {
          newVal = IX.CustomConverter(proxy, ucPropName, newVal);
          container[propName] = newVal;
        }

        break;
    }

    if (handler) {
      (handler as IXEvent).Invoke(newVal, proxy, oldVal);
    }
  });
}</pre>
<p>Again, enough to implement the proof-of-concept.&nbsp; </p>
<h4><a name="CustomConverter59">CustomConverter</a></h4>
<pre>private static CustomConverter&lt;T&gt;(container: T, ucPropName: string, newVal: string): any {
  let converter = `onConvert${ucPropName}`;

  if (container[converter]) {
    newVal = container[converter](newVal);
  }

  return newVal;
}</pre>
<h3><a name="CreateButtonHandlers60">CreateButtonHandlers</a></h3>
<p>Buttons (and button-like things, like checkboxes and radio buttons) have 
their own unique requirements.&nbsp; Checkboxes and radio buttons (which are 
<code>INPUT</code> HTML elements) have a <code>checked</code> 
property, whereas buttons do not.&nbsp; The proxy'd class must implement the 
expected &quot;on....&quot; which must be assigned to an <code>IXEvent</code> to support multicast 
events.</p>
<pre>private static CreateButtonHandlers&lt;T&gt;(container: T, proxy: T) {
  Object.keys(container).forEach(k =&gt; {
    if (k.startsWith(&quot;on&quot;) &amp;&amp; k.endsWith(&quot;Clicked&quot;)) {
      let elName = IX.LeftOf(IX.LowerCaseFirstChar(k.substring(2)), &quot;Clicked&quot;);
      let el = document.getElementById(elName);
      let anonEl = el as any;

      if (el) {
        if (!anonEl._proxy) {
        anonEl._proxy = this;
      }

      if (!anonEl._clickEventWiredUp) {
        anonEl._clickEventWiredUp = true;

        switch (el.nodeName) {
          case &quot;BUTTON&quot;:
            IX.WireUpEventHandler(el, container, proxy, null, &quot;click&quot;, k);
            break;

          case &quot;INPUT&quot;:
            // sort of not necessary to test type but a good idea, especially for checkboxes and radio buttons.
            let typeAttr = el.getAttribute(&quot;type&quot;);

            if (typeAttr == &quot;checkbox&quot; || typeAttr == &quot;radio&quot;) {
              IX.WireUpEventHandler(el, container, proxy, &quot;checked&quot;, &quot;click&quot;, k);
            } else {
              IX.WireUpEventHandler(el, container, proxy, null, &quot;click&quot;, k);
            }

            break;
          }
        }
      }
    }
  });
}</pre>
<h3><a name="CreateBinders61">CreateBinders</a></h3>
<p>Binders handle real-time events such as keyup as well as when an input 
element loses focus.&nbsp; Adding to the complexity is the concept that a binder 
might be associated with multiple checkboxes or radio buttons and bind the 
list of currently selected items.&nbsp; This is a confusing piece of code, as 
both array and non-array properties can be bound.&nbsp; It is assumed that if an 
array is being bound, the array is populated with the selected checkboxes or 
radio buttons (though technically, a radio button should be exclusive.)&nbsp; 
Otherwise, the property itself is set with either the checked state or the 
element's value.&nbsp; Lastly, an optional &quot;op&quot; (operation) can be defined 
before the value is set <i>on the proxy</i>.&nbsp; Setting the value on the 
proxy rather than the <i>proxy'd</i> object invokes the proxy setter which can 
define further behaviors but ultimately also assigns the value to the original 
container object.</p>
<pre>// We assume binders are created on input elements. Probably not a great assumption.
private static CreateBinders&lt;T&gt;(container: T, proxy: T): void {
  Object.keys(container).forEach(k =&gt; {

    if (container[k].binders?.length ?? 0 &gt; 0) {
      let binderContainer = container[k] as IXBinder;
      let binders = binderContainer.binders as IXBind[];

      if (binderContainer.asArray) {
        binders.forEach(b =&gt; {
          let elName = b.bindFrom;
          let el = document.getElementById(elName);

          let typeAttr = el.getAttribute(&quot;type&quot;);

          // Limited support at the moment.
          if (typeAttr == &quot;checkbox&quot; || typeAttr == &quot;radio&quot;) {
            el.addEventListener(&quot;click&quot;, ev =&gt; {
              let values: string[] = [];

              // Get all the items currently checked
                binders.forEach(binderItem =&gt; {
                  let boundElement = (document.getElementById(binderItem.bindFrom) as HTMLInputElement);
                  let checked = boundElement.checked;

                  if (checked) {
                    values.push(boundElement[binderItem.attribute]);
                  }
                });

                let ret = binderContainer.arrayOp(values);
                proxy[k] = ret;
              });
            }
          });
        } else {
          binders.forEach(b =&gt; {
            let elName = b.bindFrom;
            let el = document.getElementById(elName);
            console.log(`Binding receiver ${k} to sender ${elName}`);

            let typeAttr = el.getAttribute(&quot;type&quot;);
  
            if (typeAttr == &quot;checkbox&quot; || typeAttr == &quot;radio&quot;) {
              el.addEventListener(&quot;click&quot;, ev =&gt; {
                let boundAttr = b.attribute ?? &quot;checked&quot;;
                let v = String((ev.currentTarget as HTMLInputElement)[boundAttr]);
                v = b.op === undefined ? v : b.op(v);
                proxy[k] = v;
              });
            } else {
              // Realtime typing
              el.addEventListener(&quot;keyup&quot;, ev =&gt; {
                let v = (ev.currentTarget as HTMLInputElement).value;
                // proxy[elName] = v; --- why?
                v = b.op === undefined ? v : b.op(v);
                proxy[k] = v;
              });

              // Lost focus, or called when value is set programmatically in the proxy setter.
              el.addEventListener(&quot;changed&quot;, ev =&gt; {
                let v = (ev.currentTarget as HTMLInputElement).value;
                v = b.op === undefined ? v : b.op(v);
                proxy[k] = v;
              });
          }
        });
      }
    }
  });
}</pre>
<h3><a name="Initialize62">Initialize</a></h3>
<p>This last function started off simple and ended up being more complicated as 
it needs to handle not just native non-array types, but also arrays and DOM 
elements like &quot;select&quot;:</p>
<pre>private static Initialize&lt;T&gt;(container: T, proxy: T): void {
  Object.keys(container).forEach(k =&gt; {
    let name = container[k].constructor?.name;

    switch (name) {
      case &quot;String&quot;:
      case &quot;Number&quot;:
      case &quot;Boolean&quot;:
      case &quot;BigInt&quot;:
        proxy[k] = container[k]; // Force the proxy to handle the initial value.

        break;

      case &quot;Array&quot;:
        // Special handling of arrays that have an initial set of elements so we don't duplicate the elements.
        // At this point, container[k] IS the proxy (IXArrayProxy) so we have the issue that the proxy is set to 
        // the array but the UI elements haven't been created. If we just do: 
        // proxy[k] = container[k]; 
        // This will initialize the UI list but push duplicates of the into the array.

        // So, for arrays, we want to create the array proxy as an empty array during initialization instead,
        // then set the empty proxy to the container, then the container to the proxy.
        if (container[k]._id != k) {
          let newProxy = IXArrayProxy.Create(k, container);
          newProxy[k] = container[k];
          container[k] = newProxy;
        }

        break;

      case &quot;IXSelector&quot;:
        // Similar to &quot;Array&quot; above, except we are proxying the IXSelector.options array, not the container itself.
        if (container[k]._id != k) {
          // Set the element that this IXSelector manages so we know what to do when value and text are assigned.
          container[k]._element = document.getElementById(k);
          let selector = container[k] as IXSelector;

          // Proxy the options array so we can initialize it as well as push/pop.
          if (selector.options.length &gt; 0) {
          let newProxy = IXArrayProxy.Create(k, container);
            newProxy[k] = selector.options;
            selector.options = newProxy;
          }
        }

        break;
    }
  });
}</pre>
<h3><a name="Arrays63">Arrays</a></h3>
<p>Arrays are something of nightmare.&nbsp; Array functions, such as <code>push</code>, <code>pop</code>, 
and <code>length</code>, are actually vectored through the proxy's getter (as would any other 
function on a proxy'd object):</p>
<pre>static ArrayChangeHandler = {
  get: function (obj, prop, receiver) {
  // return true for this special property, so we know that we're dealing with a ProxyArray object.
  if (prop == &quot;_isProxy&quot;) {
    return true;
  }

  // Setup for push and pop, preserve state when the setter is called.
  // Very kludgy but I don't know of any other way to do this.
    if (prop == &quot;push&quot;) {
    receiver._push = true;
  }

  if (prop == &quot;pop&quot;) {
    receiver._pop = true;
  }

  if (prop == &quot;length&quot;) {
    return obj[receiver._id].length;
  }

  return obj[prop];
},</pre>
<p>Notice that a flag is being set as to whether the operation about to be 
performed, in the setter, is a <code>push</code> or <code>pop</code>!&nbsp; This 
information is used to determine how the array should be adjusted in the setter 
when the length is changed.&nbsp; Popping an array element, it turns out, merely 
changes the length of the array:</p>
<pre>set: function (obj, prop, val, receiver) {
  // we're looking for this pattern:
  // &quot;setting 0 for someList with value Learn Javascript&quot;
  let id = receiver._id;
  console.log('setting ' + prop + ' for ' + id + ' with value ' + val);

  if (prop == &quot;length&quot; &amp;&amp; receiver._pop) {
    let el = document.getElementById(id);
    let len = obj[id].length;

    for (let i = val; i &lt; len; i++) {
      el.childNodes[val].remove();
      obj[id].pop();
    }

    receiver._pop = false;
  } else {</pre>
<p>If the setter is not a pop, then it is either updating an existing item in 
the array:</p>
<pre>// We might be setting an array item, or we might be doing a push, in either case &quot;prop&quot; is the index value.
if (!isNaN(prop)) {
  let el = document.getElementById(id);
  switch (el.nodeName) {
    // TODO: &quot;UL&quot;!
    case &quot;OL&quot;: {
    let n = Number(prop);
    let ol = el as HTMLOListElement;

    if (n &lt; ol.childNodes.length &amp;&amp; !receiver._push) {
      // We are replacing a node
      // innerText or innerHTML?
      (ol.childNodes[n] as HTMLLIElement).innerText = val;</pre>
<p>or we are adding an item to the array:</p>
<pre>    } else {
      let li = document.createElement(&quot;li&quot;) as HTMLLIElement;
      let v = val;

      if (val._isTemplate) {
        let t = val as IXTemplate;
        // innerText or innerHTML?
        li.innerText = t.value;
        li.id = t.id;
        v = t.value;
      } else {
        li.innerText = val;
      }

      (el as HTMLOListElement).append(li);
      obj[id].push(v);
      receiver._push = false;
    }</pre>
<p>Lastly, the array property might be being set to a whole new array:</p>
<pre>} else if (val.constructor.name == &quot;Array&quot;) {
  let el = document.getElementById(id);

  // TODO: remove all child elements?

  switch (el.nodeName) {
    case &quot;SELECT&quot;:
      (val as IXOption[]).forEach(v =&gt; {
        let opt = document.createElement(&quot;option&quot;) as HTMLOptionElement;
        opt.innerText = v.text;
        opt.value = String(v.value);
        opt.disabled = v.disabled;
        opt.selected = v.selected;
        (el as HTMLSelectElement).append(opt);
      });
    break;

    case &quot;OL&quot;:
    case &quot;UL&quot;:
      (val as []).forEach(v =&gt; {
        let li = document.createElement(&quot;li&quot;) as HTMLLIElement;
        li.innerText = v;
        (el as HTMLOListElement).append(li);
      });
    break;
  }
}</pre>
<h3><a name="IXEvent64">IXEvent</a></h3>
<p><code>IXEvent</code> (and it's helper, <code>IXSubscriber</code>) are wrappers to implement multicast 
events:</p>
<pre>export class IXSubscriber {
  subscriber: (obj: any, oldVal: string, newVal: string) =&gt; void;

  constructor(subscriber: (obj: any, oldVal: string, newVal: string) =&gt; void) {
  this.subscriber = subscriber;
}

  Invoke(obj: any, oldVal: string, newVal: string): void {
    this.subscriber(obj, oldVal, newVal);
  }
}

import { IXSubscriber } from &quot;./IXSubscriber&quot;

export class IXEvent {
  subscribers: IXSubscriber[] = [];

  // We probably only usually want the new value, followed by the container, folloed by the old value.
  Add(subscriber: (newVal: string, obj: any, oldVal: string) =&gt; void) : IXEvent {
    this.subscribers.push(new IXSubscriber(subscriber));

    return this;
  }

  Invoke(newVal: string, obj: any, oldVal: string): void {
    this.subscribers.forEach(s =&gt; s.Invoke(newVal, obj, oldVal));
  }
}</pre>
<h3><a name="IXTemplate65">IXTemplate</a></h3>
<p>This class is my lame attempt to provide for templates.</p>
<pre>export class IXTemplate {
  public _isTemplate: boolean = true;

  public value?: string;
  public id?: string;

  public static Create(t: any): IXTemplate {
    let template = new IXTemplate();
    template.value = t.value;
    template.id = t.id;

    return template;
  }

  public SetValue(val: string): void {
    document.getElementById(this.id).innerText = val;
  }
}</pre>
<p>This is dubious at best because it sets <code>innerText</code> rather than <code>innerHtml</code>, and I'm 
really not sure of the usefulness of it except that it's used in the integration 
tests.</p>
<h2><a name="Conclusion66">Conclusion</a></h2>
<p>Having come to the top of the other end of the U, I'm now reconsidering the 
entire implementation.</p>
<h3><a name="DoIneedaProxy67">Do I need a Proxy?</a></h3>
<p>By the time I was implementing an example of the comobox, and using this 
construct:</p>
<pre>selector = new IXSelector();</pre>
<p>It occurred to me, hmm, maybe all the class properties that map to DOM 
elements should be wrapped by an actual &quot;helper.&quot;&nbsp; This would allow the 
wrapper to directly implement the DOM attributes and properties of an element 
which effectively eliminates the need for a Proxy!&nbsp; It would also eliminate 
the &quot;make up my own syntax&quot;, like:</p>
<pre>.Add({ bindFrom: &quot;jane&quot;, attribute: &quot;value&quot; })</pre>
<p>or:</p>
<pre>mySpan = {
  attr: { title: &quot;&quot; }
};</pre>
<p>The &quot;initialization&quot; process would 
merely iterate over the class properties (they still have to exist) and initialize the 
property with the DOM ID, thus the specific implementation can manipulate the 
DOM directly rather than through a proxy.&nbsp; And I'd still have Intellisense 
because the wrapper implemention would have the DOM attributes and properties 
I'd be touching.</p>
<p>Of course, this involves a ton of work - ideally the DOM for each element 
would have to be re-implemented, and that's just for native HTML elements.&nbsp; 
What about third party UI libraries?&nbsp; One approach would be to do this a 
piece at a time, as needed in the web apps that I'd be writing with this 
framework.&nbsp; Furthermore, I could derive such wrapper classes from the 
HTML.... interfaces that already exist, for example,
<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement">
HTMLButtonElement</a>.&nbsp; That would work, but I also really like the beauty of:</p>
<pre>nc.name = &quot;Hello World!&quot;;</pre>
<h3><a name="BothProxyandDOMWrapper68">Both Proxy and DOM Wrapper</a></h3>
<p>There's no reason the implementation cannot support both by inspecting the 
constructor name, as I'm already doing in the initialization process.&nbsp; This 
would therefore leave it up to the developer:</p>
<ol>
	<li>For native types, a proxy would wrap basic behaviors.</li>
	<li>For wrapper types, a proxy would not be used, giving the developer more 
	fine-grained control of the element.</li>
</ol>
<p>This would also eliminate any arcane syntax that the developer would have to 
learn, as the wrapper would implement the HTML... interfaces that already exist 
and with which one would already be familiar.</p>
<p>Also, all that krufty code to handle array push, pop, and assignment would be 
a lot cleaner!</p>
<h3><a name="TheFutureIsEmerging69">The Future Is Emerging</a></h3>
<p>Therefore I can only conclude that after having gone through the U process, I 
now know what the future will look like, at least for the framework that <i>I</i> 
want to use!</p>

</body>

</html>