<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>TypeScript</title>
</head>

<body>

<p>TypeScript Model - Element Binding, Two Way Data Binding, Events, And More 
With Proxies</p>
<h2>Introduction</h2>
<p>I have found it a useful 
exploration of how to leverage the Proxy type to bind class properties to 
models, achieve two way binding, subscribe to UI events, and so forth, all using 
actual &quot;edit-time&quot; types for type safety and Intellisense support - as in, no 
strings referencing DOM elements by their ID's.</p>
<p>The impetus for this proof of concept is that I really despise string 
literals for ID's, which it seems that just about every one of those third party 
frameworks still is stuck on, and of course, native DOM manipulation is as well.&nbsp; 
I also wanted to create a lightweight framework for providing two-way data 
binding, events, attribute handling, and so forth.</p>
<p>Thus &quot;IX&quot; is born, which is short for &quot;Interacx&quot;, which 
was a WinForm suite of 
tools that I created a long time ago to automate data manipulation without using 
an ORM.&nbsp; I decided to repurpose the name since WinForm applications are, well, 
passé.</p>

<p>And to make things interesting, I'm going to use some Vue examples as 
comparison to the implementation I've developed here using proxies.</p>
<h3>Pros</h3>
<p>Working with the code I've developed here, I find several advantages:</p>
<ol>
	<li>I'm not hardcoding DOM ID string literals.</li>
	<li>I'm able to leverage the type safety of TypeScript.</li>
<li>Being able to refer to DOM elements as object properties leverages Visual 
Studio's Intellisense.</li>
	<li>It's really easy to wire up events and bindings.</li>
<li>It was quite easy to write unit tests - in fact, the unit tests are one of 
the more interesting aspects of this code, in my opinion.</li>
	<li>I'm not putting &quot;declarative code&quot; in the HTML<ol>
	<li>The HTML remains completely clean.</li>
	<li>The business logic is implemented in code. </li>
	<li>You don't have to inspect both code and HTML to figure out what in the 
	world is actually going on.</li>
</ol></li>
	<li>Point #6</li>
	<li>Point #6</li>
	<li>Point #6</li>
</ol>
<p>I cannot reiterate enough how important, at least to me, point #6 is.&nbsp; 
With a large web application, I have pulled my hair out bouncing between code 
and markup to figure out what the conditions, loops, and rendering is, and it is 
a frustrating experience.&nbsp; To me, the idea of including declarative syntax 
at the UI level that is driven by effectively business data/rules is bad, no 
horrible, design.&nbsp; It's why I don't use Razor or similar rendering engines.&nbsp; 
I personally think that custom tags in the HTML, particularly &quot;if&quot; and &quot;loop&quot; 
tags, to control UI rendering is one of the worst ideas to come out of so-called 
modern web development.</p>
<h3>Cons</h3>
<p>So let's be realistic:</p>
<ol>
	<li>The syntax requires a specific mapping between the DOM element ID and 
	the object's property name.</li>
<li>Proxies are slower.</li>
	<li>The code to work with proxies is highly specialized.</li>
	<li>The code to work with arrays is bizarre.</li>
	<li>The code here is really incomplete with regards to all the DOM 
	attributes, properties, and events that could be handled.</li>
	<li>I have no idea whether the code here is actually robust enough to handle 
	#4.</li>
	<li>I have yet to explore whether this concept works well with third party 
	widget libraries, my favorite being jqWidgets.</li>
</ol>
<p>And I really doubt anyone is going to say, &quot;ooh, let's use IX to build a 
major website&quot;, except perhaps for me!</p>
<h3>So Why Bother?</h3>
<ol>
	<li>I like to explore different ways to solve the warts of web development.</li>
<li>I haven't come across anyone else attempting this.</li>
	<li>It's quite interesting to learn about proxies.</li>
<li>This was fun!</li>
</ol>
<p>So without further ado, let's start exploring!</p>
<h2>Simple Data Binding of Inner HTML</h2>
<p>Let's start with simple data binding of the inner HTML associated with a <code>DIV</code>.</p>
<h3>The Vue Way</h3>
<pre>&lt;div id=&quot;app&quot;&gt;
  {{ message }}
&lt;/div&gt;

var app = new Vue({
  el: '#app',
  data: {
   message: 'Hello Vue!'
  }
})</pre>
<p>What I don't like:</p>
<ol>
	<li>The &quot;Mustache&quot; <code>{{ }}</code> usage.</li>
	<li>The <code>#app</code>.</li>
	<li>The whole <code>data</code> object thing.</li>
</ol>
<h3>The IX Way</h3>
<pre>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;

let form = IX.CreateNullProxy(); // No associated view model.
form.app = &quot;Hello Interacx!&quot;;</pre>
<p><img border="0" src="helloIX.png" width="114" height="26"></p>
<p>That's it.</p>
<h2>Reactive Behavior</h2>
<p>The next example is displaying some realtime computed value as part of a SPAN 
title.</p>
<h3>The Vue Way</h3>
<pre>&lt;div id=&quot;app-2&quot;&gt;
  &lt;span v-bind:title=&quot;message&quot;&gt;
    Hover your mouse over me for a few seconds
    to see my dynamically bound title!
  &lt;/span&gt;
&lt;/div&gt;

var app2 = new Vue({
  el: '#app-2',
  data: {
    message: 'You loaded this page on ' + new Date().toLocaleString()
  }
})</pre>
<h3>The IX Way</h3>
<pre>&lt;span id=&quot;mySpan&quot;&gt;However your mouse over me for a few seconds to see the dynamically bound title!&lt;/span&gt;

class HoverExample {
  mySpan = {
    attr: { title: &quot;&quot; }
  };

  onMySpanHover = new IXEvent();
}

let form = IX.CreateProxy(new HoverExample());
form
  .onMySpanHover
  .Add(() =&gt; 
    hform.mySpan.attr.title = `You loaded this page on ${new Date().toLocaleString()}`);</pre>
<p>More verbose but the benefit is that you're using a repeatable pattern of 
using a multicast event handler.&nbsp; I did have an implementation where I 
could just set the title as a function, but I didn't like the one-off 
implementation behind the scenes that this required.</p>
<h2>Conditionals</h2>
<p>I also really don't like to make a mess of the markup with declarative code 
elements.</p>
<h3>The Vue Way</h3>
<pre>&lt;div id=&quot;app-3&quot;&gt;
  &lt;span v-if=&quot;seen&quot;&gt;Now you see me&lt;/span&gt;
&lt;/div&gt;

var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})</pre>
<h3>The IX Way</h3>
<p>In IX, conditional behaviors are implemented through the event mechanism, 
usually to manipulate element attributes.&nbsp; Diverging slightly from the Vue 
example above, note the addition of two buttons to toggle the visibility of the <code>SPAN</code>:</p>
<pre>&lt;span id=&quot;seen&quot;&gt;Now you see me...&lt;/span&gt;
 &lt;!-- Two ways to declare a button --&gt;
&lt;button id=&quot;show&quot;&gt;Show&lt;/button&gt;
&lt;input id=&quot;hide&quot; type=&quot;button&quot; value=&quot;Hide&quot; /&gt;


class VisibilityExample {
  seen = {
    attr: { visible: true }
  };


  onShowClicked = new IXEvent().Add((_, p) =&gt; p.seen.attr.visible = true);
  onHideClicked = new IXEvent().Add((_, p) =&gt; p.seen.attr.visible = false);
}

IX.CreateProxy(new VisibilityExample());</pre>
<p>These are wired up to two buttons, hence the event handlers.</p>
<p>Here:</p>
<ol>
	<li>We have a consistent way of manipulating element attributes.</li>
	<li>Intellisense works perfectly in Visual Studio.</li>
	<li>No &quot;string&quot; element name.</li>
</ol>
<h2>Loops</h2>
<h3>The Vue Way</h3>
<pre>&lt;div id=&quot;app-4&quot;&gt;
  &lt;ol&gt;
    &lt;li v-for=&quot;todo in todos&quot;&gt;
      {{ todo.text }}
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;

var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: 'Learn JavaScript' },
      { text: 'Learn Vue' },
      { text: 'Build something awesome' }
    ]
  }
})</pre>
<h3>The IX Way</h3>
<pre>&lt;ol id=&quot;someList&quot;&gt;&lt;/ol&gt;

class ListExample {
  someList: string[] = [&quot;Learn Javascript&quot;, &quot;Learn IX&quot;, &quot;Wear a mask!&quot;];
}

IX.CreateProxy(new ListExample());</pre>
<p>Result:</p>
<p><img border="0" src="loop1.png" width="152" height="91"></p>
<p>Given that most lists come from a data source rather being hard coded:</p>
<pre>&lt;ol id=&quot;someList&quot;&gt;&lt;/ol&gt;

class ListExample {
  someList: string[] = [];
}

let listForm = IX.CreateProxy(new ListExample());

listForm.someList.push(&quot;Learn Javascript&quot;);
listForm.someList.push(&quot;Learn IX&quot;);
listForm.someList.push(&quot;Wear a mask!&quot;);</pre>
<p>Or:</p>
<pre>let listForm = IX.CreateProxy(new ListExample());
let items = [&quot;Learn Javascript&quot;, &quot;Learn IX&quot;, &quot;Wear a mask!&quot;];
listForm.someList = items;</pre>
<h2>Button Clicks</h2>
<h3>The Vue Way</h3>
<pre>&lt;div id=&quot;app-5&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

var app5 = new Vue({
  el: '#app-5',
  data: {
  message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})</pre>
<h3>The IX Way</h3>
<pre>&lt;div&gt;
  &lt;p id=&quot;message&quot;&gt;&lt;/p&gt;
  &lt;button id=&quot;reverseMessage&quot;&gt;Reverse Message&lt;/button&gt;
&lt;/div&gt;

class ReverseExample {
  message = &quot;Hello From Interacx!&quot;;
  onReverseMessageClicked = new IXEvent()
    .Add((_, p: ReverseExample) =&gt; p.message = p.message.split('').reverse().join(''));
}

IX.CreateProxy(new ReverseExample());</pre>
<p>Again, notice:</p>
<ol>
	<li>No &quot;Mustache&quot; {{ }} syntax required.</li>
<li>No &quot;#id&quot; string to identify the element ID.</li>
	<li>The event mechanism, being multicast, allows us to wire up more than one 
	event (not illustrated, but that's point of using events.)</li>
</ol>
<p><img border="0" src="r1.png" width="170" height="54"></p>
<p>After clicking on the button:</p>
<p><img border="0" src="r2.png" width="161" height="52"></p>
<h2>Data Conversion</h2>
<p>The following example is similar to Vue's <code>.number</code> attribute but the actual 
implementation is much more general purpose.</p>
<p>Consider this UI:</p>
<p><img border="0" src="convert.png" width="548" height="52"></p>
<p>And the markup (CSS and extraneous DIV's removed for readability):</p>
<pre>X:
&lt;input id=&quot;x&quot; class=&quot;fieldInputSmall&quot; /&gt;
Y:
&lt;input id=&quot;y&quot; class=&quot;fieldInputSmall&quot; /&gt;</pre>
<p>Here, we do not want the strings &quot;1&quot; and &quot;2&quot; to sum to &quot;12&quot;, so we implement 
converters:</p>
<pre>class InputForm {
  x: number;
  y: number;

  onXChanged = new IXEvent();
  onYChanged = new IXEvent();

  // Converters, so 1 + 2 != '12'
  onConvertX = x =&gt; Number(x);
  onConvertY = y =&gt; Number(y);

  Add = () =&gt; this.x + this.y;
}

class OutputForm {
  sum: number;
}
</pre>
<p>And the events are wired up like this:</p>
<pre>let inputForm = IX.CreateProxy(new InputForm());
let outputForm = IX.CreateProxy(new OutputForm());

inputForm.onXChanged.Add(() =&gt; outputForm.sum = inputForm.Add());
inputForm.onYChanged.Add(() =&gt; outputForm.sum = inputForm.Add());</pre>
<p>Behind the scenes, the input box text is converted to a <code>Number</code> with the 
<code>onConvertX</code> and <code>onConvertY</code> converters, and the rest is handled by the standard 
data binding of the properties for setting <code>sum</code> to the values of </code>x</code> and </code>y</code>.</p>
<p>Also, notice how you can create classes as containers to sections of the HTML.&nbsp; 
We could easily have put <code>sum</code> in the <code>InputForm</code>, but instead I wanted to 
illustrate how to use a separate container object, <code>OutputForm</code>, as a way of 
compartmentalizing the properties into separate containers.</p>
<h2>Two Way Binding</h2>
<p>We've already seen in the examples above binding between the view and the 
model.&nbsp; One of Vue's examples is direct update of one element based on the 
realtime update of an input element.&nbsp; While I can't think of a real-life 
example where one would need this, real-time updating, say of a filter criteria, 
is definitely useful, so we'll start with the Vue example:</p>
<h3>The Vue Way</h3>
<pre>&lt;div id=&quot;app-6&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
    &lt;input v-model=&quot;message&quot;&gt;
  &lt;/div&gt;

var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})</pre>
<h3>The IX Way</h3>
<p>This is already easily accomplished with events:</p>
<pre>First Name:
&lt;p id=&quot;message2&quot;&gt;/p&gt;
&lt;input id=&quot;input2&quot;/&gt;

class BidirectionalExample {
  message2: string = &quot;&quot;;
  input2: string = &quot;&quot;;

  onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}

IX.CreateProxy(new BidirectionalExample());</pre>
<p><img border="0" src="keyUp.png" width="171" height="48"></p>
<p>However, to make this more &quot;Vue-ish&quot;, we can do:</p>
<pre>class BidirectionalExample {
  message2 = new IXBinder({ input2: null });
  input2: string = &quot;&quot;;</pre>
<p>Here we are specifying the &quot;from&quot; element as the key and any &quot;value&quot; of the 
key.&nbsp; What displeases me about this is that the key cannot be implemented a 
way that leverages Intellisense and type checking.&nbsp; The best we can do is 
runtime checking that the &quot;from&quot; binder element exists.&nbsp; So at this point, 
specifying the &quot;bind from&quot; property as a string almost makes sense.&nbsp; 
Instead, I opted for this implementation:</p>
<pre>class BidirectionalExample {
  input2: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}</pre>
<p>Which is somewhat lame as well but has the advantage of supporting 
Intellisense, albeit the property your binding to must already be declared 
previously.&nbsp; Behind the scenes, we have a very simple implementation to 
extract the name, by converting the function into a string:</p>
<pre>public static nameof&lt;TResult&gt;(name: () =&gt; TResult): string {
  let ret = IX.RightOf(name.toString(), &quot;.&quot;);

  return ret;
}</pre>
<p>Sadly that's seems to be the best we can do with Javascript unless you want 
to use something like <a href="https://github.com/dsherret/ts-nameof">ts-nameof</a>, 
which I do not because ts-nameof is a compile-time transformation, and I do not 
want the developer that uses this library to have to go through hoops to get 
this to work.</p>
<p>We can also bind the same source to different targets:</p>
<pre>&lt;p&gt;
  &lt;label id=&quot;message2&quot;&gt;&lt;/label&gt;
  &lt;label id=&quot;message3&quot;&gt;&lt;/label&gt;
&lt;/p&gt;
&lt;input id=&quot;input2&quot; /&gt;

class BidirectionalExample {
  input2: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
}</pre>
<p>As well as different sources to the same target:</p>
<pre>&lt;p&gt;
  &lt;label id=&quot;message2&quot;&gt;&lt;/label&gt;
  &lt;label id=&quot;message3&quot;&gt;&lt;/label&gt;
&lt;/p&gt;
&lt;input id=&quot;input2&quot; /&gt;
&lt;input id=&quot;input3&quot; /&gt;

class BidirectionalExample {
  input2: string = &quot;&quot;;
  input3: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) })
               .Add({ bindFrom: IX.nameof(() =&gt; this.input3) });
}</pre>
<p>Here, typing in the left edit box sets messages 2 &amp; 3:</p>
<p><img border="0" src="src1.png" width="326" height="51"></p>
<p>Typing in the right edit box sets message 3:</p>
<p><img border="0" src="src2.png" width="324" height="51"></p>
<p>But as I said earlier, doing this kind of binding really doesn't make much 
sense.&nbsp; Typically, a transformation does something &quot;useful&quot;, so we have 
this contrived example:</p>
<pre>class BidirectionalExample {
  input2: string = &quot;&quot;;
  input3: string = &quot;&quot;;
  message2 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) });
  message3 = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.input2) }).Add({
    bindFrom: IX.nameof(() =&gt; this.input3), 
    op: v =&gt; v.split('').reverse().join('') 
  });

// onInput2KeyUp = new IXEvent().Add((v, p: BidirectionalExample) =&gt; p.message2 = v);
}</pre>
<p>and thus we get:</p>
<p><img border="0" src="op1.png" width="313" height="49"></p>
<h2>Checkboxes</h2>
<h3>Binding Checkbox State</h3>
<h4>The Vue Way</h4>
<p>Vue has an elegant demonstration of binding the checkbox state to the label:</p>
<pre>&lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt;
&lt;label for=&quot;checkbox&quot;&gt;{{ checked }}&lt;/label&gt;</pre>
<h4>The IX Way</h4>
<p>Given:</p>
<pre>&lt;input id=&quot;checkbox&quot; type=&quot;checkbox&quot; /&gt;
&lt;label id=&quot;ckLabel&quot; for=&quot;checkbox&quot;&gt;&lt;/label&gt;</pre>
<p>We continue to follow the pattern of using TypeScript classes and properties:</p>
<pre>class CheckboxExample {
  checkbox: boolean = false;
  ckLabel = new IXBinder({ bindFrom: IX.nameof(() =&gt; this.checkbox) });
}

IX.CreateProxy(new CheckboxExample());</pre>
<p>or, because the nameof syntax above is clumsy and we don't have a real &quot;nameof&quot; 
operator in Javascript by the time the code is transpiled, so we have to revert 
to string literals in this case:</p>
<pre>class CheckboxExample {
  checkbox: boolean = false;
  ckLabel = new IXBinder({ bindFrom: &quot;checkbox&quot; });
}

IX.CreateProxy(new CheckboxExample());</pre>
<p><img border="0" src="ckfalse.png" width="56" height="28"></p>
<p><img border="0" src="cktrue.png" width="58" height="27"></p>
<p>Or we can wire up the click event:</p>
<pre>class CheckboxExample {
  checkbox: boolean = false;
  ckLabel: string = &quot;Unchecked&quot;;

  onCheckboxClicked = 
    new IXEvent().Add(
      (_, p: CheckboxExample) =&gt; 
          p.ckLabel = p.checkbox ? &quot;Checked&quot; : &quot;Unchecked&quot;);
}

IX.CreateProxy(new CheckboxExample());</pre>
<p><img border="0" src="ckunchecked.png" width="94" height="27"></p>
<p><img border="0" src="ckchecked.png" width="87" height="29"></p>
<h3>Binding Checkbox Values</h3>
<h4>The View Way</h4>
<pre>&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;
&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;
&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Checked names: {{ checkedNames }}&lt;/span&gt;</pre>
<p>Note that the span text includes the array brackets:</p>
<p><img border="0" src="viewckarray.png" width="251" height="69"></p>
<h4>The IX Way</h4>
<p>Given:</p>
<pre>&lt;input id=&quot;jane&quot; value=&quot;Jane&quot; type=&quot;checkbox&quot; /&gt;
&lt;label for=&quot;jane&quot;&gt;Jane&lt;/label&gt;
&lt;input id=&quot;mary&quot; value=&quot;Mary&quot; type=&quot;checkbox&quot; /&gt;
&lt;label for=&quot;mary&quot;&gt;Mary&lt;/label&gt;
&lt;input id=&quot;grace&quot; value=&quot;Grace&quot; type=&quot;checkbox&quot; /&gt;
&lt;label for=&quot;grace&quot;&gt;Grace&lt;/label&gt;
&lt;br /&gt;
&lt;label id=&quot;ckNames&quot;&gt;&lt;/label&gt;</pre>
<p>We implement the container object with a special array binding (because the 
properties don't exist in the class, I can't use the &quot;nameof&quot; kludge, so the 
ID&quot;s are, sadly, string literals.)&nbsp; Of course, in the next example, I do 
have properties for the checkboxes, but I still used the string literals!</p>
<pre>class CheckboxListExample {
  ckNames = IXBinder.AsArray(items =&gt; items.join(&quot;, &quot;))
    .Add({ bindFrom: &quot;jane&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;mary&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;grace&quot;, attribute: &quot;value&quot; });
}

IX.CreateProxy(new CheckboxListExample());</pre>
<p>And we get:</p>
<p><img border="0" src="ixckarray.png" width="191" height="55"></p>
<p>Notice that we did not initialize properties with the checkbox state!&nbsp; 
If we do this:</p>
<pre>class CheckboxListExample {
  jane: boolean = false;
  mary: boolean = false;
  grace: boolean = false;
  ckNames = IXBinder.AsArray(items =&gt; items.join(&quot;, &quot;))
    .Add({ bindFrom: &quot;jane&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;mary&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;grace&quot;, attribute: &quot;value&quot; });
}

let ckListExample = IX.CreateProxy(new CheckboxListExample());</pre>
<p>We can programmatically set the check state:</p>
<pre>ckListExample.jane = true;
ckListExample.mary = true;</pre>
<p>and we see:</p>
<p><img border="0" src="cklistprog.png" width="180" height="50"></p>
<p>So one thing we note here is that the property referring to the HTML element 
is associated <i>with the checked attribute of the element</i>.&nbsp; That is an 
artifact of how IX is coded, and actually points out an interesting problem -- 
the object property maps to only one attribute of the DOM element, and IX is 
very opinionated as to what that DOM element should be, depending on what the 
element is!</p>
<h2>Radio Buttons</h2>
<h3>The View Way</h3>
<p>This example binds the value of the radio button to the span:</p>
<pre>&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;
&lt;br&gt;
&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;
&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;
&lt;br&gt;
&lt;span&gt;Picked: {{ picked }}&lt;/span&gt;</pre>
<h3>The IX Way</h3>
<p>Given:</p>
<pre>&lt;input id=&quot;marc&quot; value=&quot;Marc&quot; type=&quot;radio&quot; name=&quot;group1&quot; /&gt;
&lt;label for=&quot;marc&quot;&gt;Marc&lt;/label&gt;
&lt;input id=&quot;chris&quot; value=&quot;Chris&quot; type=&quot;radio&quot; name=&quot;group1&quot; /&gt;
&lt;label for=&quot;chris&quot;&gt;Chris&lt;/label&gt;
&lt;br /&gt;
&lt;label id=&quot;rbPicked&quot;&gt;&lt;/label&gt;</pre>
<p>We add two binders, whichever one is clicked becomes the one whose binder 
event is fired.&nbsp; Again, note in this example I'm not using the &quot;nameof&quot; 
syntax because in this case the property doesn't exist!</p>
<pre>class RadioExample {
  rbPicked = new IXBinder({ bindFrom: &quot;marc&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;chris&quot;, attribute: &quot;value&quot; });
}

IX.CreateProxy(new RadioExample());</pre>
<p>thus updating to the current radio button:</p>
<p><img border="0" src="rb1.png" width="132" height="48"></p>
<p><img border="0" src="rb2.png" width="120" height="43"></p>
<p>And if we want to programmatically set the radio button state, define the 
properties:</p>
<pre>class RadioExample {
  marc: boolean = false;
  chris: boolean = false;
  rbPicked = new IXBinder({ bindFrom: &quot;marc&quot;, attribute: &quot;value&quot; })
    .Add({ bindFrom: &quot;chris&quot;, attribute: &quot;value&quot; });
}</pre>
<p>and after proxy initialization, set the state:</p>
<pre>let rbExample = IX.CreateProxy(new RadioExample());
rbExample.chris = true;</pre>
<p><img border="0" src="rb2.png" width="120" height="43"></p>
<h2>ComboBoxes</h2>
<h2>SVG Example</h2>
<p>Vue has a fun SVG example that I thought would be a decent proof of concept 
of doing something a bit more challenging than working with basic DOM elements.</p>
<p><a href="https://vuejs.org/v2/examples/svg.html">
https://vuejs.org/v2/examples/svg.html</a></p>
<h2>Implementation Patterns</h2>
<h2>Behind the Scenes</h2>
<h3>TypeScript Does Not Mean Runtime Types</h3>
<p>TypeScript is fantastic for ensuring type safety when <i>writing</i> code.&nbsp; 
Unfortunately, by the time the code has been transpiled to JavasScript, all that 
type information that the IDE is using is of course lost.&nbsp; This is 
unfortunate because there are times in the code that I really wish I had type 
information.</p>
<p>&nbsp;</p>
<h2>Integration Tests</h2>
<p>We can easily test the behavior of IX by directly inspecting DOM elements 
after model changes, and vice versa.&nbsp; And I prefer to use the phrase 
&quot;integration test&quot; rather than &quot;unit test&quot; because we're not testing low level 
functions in the IX library -- we are testing the integration of the DOM 
elements with object properties.&nbsp; </p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</body>

</html>